\section{Проектирование и реализация приложения}
Для проектирования системы использовался универсальный язык моделирования UML с использованием редактора диаграмм Visual Paradigm Community Edition v.16.2\cite{7}. При проектировании системы, соответствующая вышеописанным требованиям, были разработаны следующие диаграммы:

\begin{enumerate}
	\item диаграмма вариантов использования платформы;
	\item диаграммы описания ресурсов RestAPI 
\end{enumerate}

\subsection{Проектирование базы данных}

В качестве СУБД для нашего проекта мы выбрали MongoDB. Актуальность выбора мы описали в предыдущей главе. Данное СУБД имеет следующие уровни представления данных:
\begin{enumerate}
	\item Документ - JSON-объект имеющий произвольное число полей. Поля могут хранить как простое значение, так и вложенные объекты и массивы. Для каждого документа в MongoDB определен уникальный идентификатор. При добавлении документа в коллекцию данный идентификатор создается автоматически.
	\item Коллекция (аналог таблиц в реляционных базах данных) - однотипные документы хранятся в отдельной коллекции. Документы в коллекции могут быть проиндексированы. Доступ к документу возможен как по ключу, так и по значению полей.
	\item База данных - набор коллекций.
\end{enumerate}

При проектировании нашей базы данных были определены следующие сущности требующие описания набора атрибутов:

\begin{enumerate}
	\item Продукты
	\item Пользователи
	\item Токены
\end{enumerate}

Контейнерами сущностей  в MongoDB являются коллекции. Ниже представлены описание структуры документов для каждой коллекции с перечислением ключевых свойств.



Продукты
\begin{lstlisting}
product = {
	"name": string,		`-- название продукта`
	"barcode": string,		`-- штрих-код продукта `
	"composition":[array],	`-- состав продукта`
	"comment": string,		`-- комментарии к продукту`
	"gost": string,		`-- номер ГОСТ-стандарта`
	"net mass": string,		`-- масса-нетто продукта`
	"keeping time": string,		`-- срок годности`
	"storage conditions": string,	`-- условия хранения`
	"esl": {  						`-- пищевая ценность продукта`
			"protein": number, `-- количество белков на 100 грамм продукта`
			"fats": number,	`-- количество жиров на 100 грамм продукта`
			"carbohydrates": number, `-- количество углеводов на 100 грамм`
			"calorie": number, `-- количество калорий на 100 грамм продукта`
	}
	"packing type": string  `-- тип упаковки`
}
\end{lstlisting}

Пользователи
\begin{lstlisting}
users = {
	"_id": Objectid,	`-- уникальный идентификатор пользователя` 
	"name": string,		`-- имя пользователя(логин)`			
	"password": string,		`-- хеш пароля пользователя`
	"unacceptable_products": [array]	`-- список недопустимых продуктов`
}
\end{lstlisting}

Черный список токенов обновления
\begin{lstlisting}
token_blacklist = {
	"_id": Objectid,	`-- уникальный идентификатор` 
	"jti": string,		`-- токен обновления`			
	"created_at": date,		`-- время добавления токена в формате UTC`
	"user_id": Objectid		`-- уникальный идентификатор пользователя`
}
\end{lstlisting}

В черном списке будут храниться токены обновления пользователей с неистекшим сроком жизни, чтобы исключить возможность повторного использования для получения токена доступа. По истечении срока жизни токены автоматический удаляются из коллекции.

\subsection{Реализация серверной части проекта}

Для описания общего представления о функциональном назначении
платформы была разработана диаграмма вариантов использования представленная на рисунке \ref{usecase}. С платформой взаимодействует два актера:
\begin{enumerate}
	\item гость -- пользователь не авторизованный в системе;
	\item авторизованный пользователь. 
\end{enumerate}
\addimghere{usecase}{0.80}{Архитектура полной виртуализации}{usecase}

Гость платформы имеет следующие варианты использования:
\begin{enumerate}
	\item регистрация в системе;
	\item  авторизация в системе.
\end{enumerate}

Авторизованный пользователь имеет следующие варианты использования:
\begin{enumerate}
	\item получение продукта -- получение полной информации о продукте по штрих-коду и списка недопустимых продуктов присутствующих в составе;
	\item добавление недопустимых продуктов -- добавление нежелательного продукта в коллекцию;
	\item удаление недопустимых продуктов -- удаление нежелательного продукта из коллекции.
\end{enumerate}

Для дальнейшего проектирования необходимо ввести понятие <<ресурс>>. Ресурс в REST-архитектуре является ключевой абстракцией информации. Любая информация, которая может быть названа, может быть ресурсом.
Сам Рой Филдинг в своей диссертации дает такое определение:<<Любая информация, которая может быть названа, может быть ресурсом>>. Другими словами, любое понятие, которое может быть объектом гипертекстовой ссылки, должно вписываться в определение ресурса. Исходя из требований к реализуемому проекту можно выделить следующие ресурсы:
\begin{enumerate}
	\item пользователи;
	\item продукты;
	\item недопустимые продукты;
	\item токены.
\end{enumerate}

Проектирование будем производить в среде visual paradigm, который предоставляет сервис для моделирования RestAPI. На рисунке \ref{user_resource} представлен модель RestAPI для ресурса пользователь. Для данного ресурса доступны два действия: регистрация и авторизация. На модели белая стрелка в черном квадрате направленная внутрь блока действия, обозначает запрос(request) к серверу, а обратная ответ(response). В заголовке блока действия указывается тип HTTP-запроса и URL. В синих блоках указываются параметры запроса и формат передаваемых параметров. При регистрации пользователя на сервер отправляется POST-запрос с необходимыми параметрами по указанному URL. В зависимости успешности действия возвращается соответствующй ответ. На рисунках \ref{product_resourse} -- \ref{token_resourse} представлены модели для остальных ресурсов. Не будем приводить описание для каждого ресурса, так как они анологичны приведенному выше.
\addimghere{user_resource}{0.99}{Модель RestAPI для ресурса Пользователи}{user_resource}
\addimghere{product_resourse}{0.80}{Модель RestAPI для ресурса Продукты}{product_resourse}
\addimghere{unacceptable_product}{1.03}{Модель RestAPI для ресурса Недопустимые продукты}{unacceptable_product}
\addimghere{token_resourse}{0.80}{Модель RestAPI для ресурса Токены}{token_resourse}

Опираясь на спроектированные модели, были разработаны методы для каждого ресурса требуемые для полноценной работы сервиса, которым присвоены соответствующие маршруты. В таблице \ref{APIdescription} приводится описание всех реализованных методов. Листинг кода реализованного сервера приведен в приложении А. Ниже приводится описание основных параметров конфигурации реализованного сервера:
\begin{enumerate}
	\item SECRET KEY -- секретный ключ, который использует Flask при
	вычислении хэша паролей. Пакетное расширение jwt extended использует его для генерации подписи при создании токенов. Секретный ключ хранится отдельно от программного кода и передается посредством переменных окружения (environment variables), при развертке данного приложения на сервере;
	\item JWT ACCESS TOKEN EXPIRES -- срок жизни для токена доступа.  Задаем равной 30 минутам;
	\item JWT REFRESH TOKEN EXPIRES -- срок жизни для токена обновления. Задаем равной 24 часам;
	\item MONGO URI -- URL сервера с MongoDB с необходимыми
	данными авторизации;
\end{enumerate}

Все ресурсы на стороне сервера требуют авторизации с использованием токенов доступа, за исключением ресурсов, необходимых для аутентификации. Refresh-токен позволяет клиентам запрашивать новые access-токены по истечении их времени жизни. Refresh-токен выдается на более длительный срок, чем access-токен, и по истечению времени его жизни клиенту необходимо вновь пройти процесс аутентификации.

\begin{singlespacing}
	\begin{table}[H]
		\caption{Описание реализованного RestAPI}\label{APIdescription}
		\begin{tabular}{|  p{80pt} |  p{80pt} |  p{290pt} |}
			\hline 
			URL & Метод & Описание \\
			\hline
			/registration & POST & Регистрация пользователя с переданными ар-
			гументами. Результатом является сообщение об успешной регистрации пользователя, либо сообщеие о соответствующей ошибке с HTTP-кодом. \\
			\hline
			/login & POST & Аутентификация пользователя по логину и па-
			ролю. Результатом является access- и refresh- токены, либо сообщеие о соответствующей ошибке с HTTP-кодом. \\
			\hline
			/refresh & POST & Обновление access-токена на основе передан-
			ного refresh-токена. Результатом является access-токен. \\
			\hline
			/unacceptable products & POST & Добавление недопустимого продукта для пользователя. Необходим заголовок авторизации. Результатом является сообщение об успешном добавлении продукта, либо сообщеие о соответствующей ошибке с HTTP-кодом. \\
			\hline
			/unacceptable products & DELETE & Удаление недопустимого продукта из списка хранимой в базе данных. Необходим заголовок авторизации. Результатом является сообщение об успешном удалении продукта, либо сообщеие о соответствующей ошибке с HTTP-кодом. \\
			\hline
			/product & POST & Получение информации о продукте по преданному штрих-коду. Необходим заголовок авторизации. Результатом является полнаяинформация о продукте, либо сообщеие о соответствующей ошибке с HTTP-кодом. \\
			\hline
		\end{tabular}
		Источник: собственная разработка
	\end{table}
\end{singlespacing}

В этом параграфе была спроектирована и реализована серверная часть приложения соответствующая архитектурному стилю REST. Отображена диаграмма вариантов использования сервиса, разработаны модели для каждого ресурса и реализованы соответствующие для них методы.
\newline
\newline

\subsection{Реализация клиентской части проекта}

Согласно требованиям архитектура приложения должна соответствовать шаблону проектирования MVVM\cite{8}. На рисунке \ref{MVVM} представлена структура нашего приложения. Для изображения диаграммы использована среда проектирования Visual Paradigm Community Edition v.16.2.

\addimghere{MVVM}{1}{Архитектура приложения}{MVVM}

В классе ViewModel будет реализована логика приложения. View отвечает за работу с компонентами пользовательского интерфейса. Для отображения в пользовательском интерфейсе даных из ViewModel применяется хранилище данных LiveData\cite{9}.
LiveData - хранилище данных, работающее по принципу паттерна Observer (наблюдатель). Это хранилище умеет делать две вещи:
\begin{enumerate}
	\item В него можно поместить какой-либо объект;
	\item На него можно подписаться и получать объекты, которые в него помещают.
\end{enumerate}

Activity подписывается на LiveData и получает данные, которые помещает в него ViewModel. В Repository будут реализованы методы для получения данных из нашего сервера. Для описания и отправки HTTP-запросов применяется библиотека Retrofit\cite{10}. Интерфейсы всех необходимых запросов описываются в APIService.

Пользовательский интерфейс приложения состоит из 5 страниц(Fragments) наследуемые от одного Activity:
\newline
\begin{enumerate}
	\item Главная;
	\item Авторизация;
	\item Регистрация;
	\item Состав продукта;
	\item Список недопустимых продуктов.
\end{enumerate}

На рисунке \ref{NavGraf} представлен разработанный навигационный граф нашего приложения.

\addimghere{NavGraf}{1}{Навигационный граф приложения}{NavGraf}

Рассмотрим подробнее реализованные страницы приложения. На рисунке \ref{home} представлена разработанная домашняя страница клиентского приложения. Данная страница содержит следующие компоненты:
\newline
\begin{enumerate}
	\item поле для ввода штрих-кода продукта;
	\item кнопку для сканирования штрих-кода через камеру на телефоне
	\item кнопку получить состав
\end{enumerate}

При активации кнопки <<Получить состав>> отправляется HTTP-запрос на сервер для получения необходимой информации о продукте и переход на страницу "Состав продукта". Для получения успешного ответа от сервера в заголовке запроса необходимо передать токен доступа, для этого пользователь должен быть авторизован. Страница авторизации представлена на рисунке \ref{login}.
\addimghere{home}{0.5}{Домашняя страница}{home}
При условии отсутствия исключении вовремя выполнения запроса, ViewModel получает информацию о продукте от сервера и заносит в хранилище LiveData. Наблюдатель, <<Состав продукта>> представленный на рисунке \ref{compos}, видит изменения в хранилище данных и отображает данные для пользователя. 
\addimghere{compos}{0.5}{Состав продукта}{compos}
При авторизации пользователя ViewModel получает токены доступа и обновления. Для сохранения токенов и передачи в заголовок каждого запроса  используется SharedPreferences\cite{11}. SharedPreferences позволяет  сохранять данные в виде пар ключ-значение. Android хранит SharedPreferences в виде XML файла в папке sharedprefs. Это позволяет исключить потерю токеннов при закрытии приложения и отказаться от использования базы данных на стороне клиента. Использование приватного режима сохранения (PRIVATE), не позволит другим приложениям иметь доступ к этим файлам и обеспечит необходимую безопасность. Для регистрации пользователя на сервере необходимо активировать кнопку <<Регистрация>> и приложение перейдет на необходимую страницу. Пользовательский интерфейс страницы регистрации приведен на рисунке \ref{registration}.


\addimghere{login}{0.70}{Страница авторизации}{login}

\addimghere{registration}{0.70}{Страница регистрации}{registration}

На рисунке \ref{unaccept} представлена страница добавления  недопустимых для пользователя продуктов.

\addimghere{unaccept}{0.5}{Добавление недопустимых продуктов}{unaccept}

Для добавления продуктов в список недопустипых, необходимо ввести в поле ввода нежелательныей продукт и активировать кнупку <<Добавить>>.
Сервер обработает полученный запрос от клиента, обновит в базе данных список и отправит для отображения пользователю.

Основные и наиболее важные фрагменты реализованного кода клиентской части приведены в приложении Б. 

\clearpage