\section{Обзор используемых технологий}

\subsection{Архитектура REST}
Термин REST ввел Рой Филдинг, один из создателей протокола HTTP, в своей докторской диссертации "Архитектурные стили и дизайн сетевых программных архитектур" ("Architectural Styles and the Design of Network-based Software Architectures")\cite{1} в 2000 году. REST — это акроним, сокращение от английского Representational State Transfer — передача состояния представления. Архитектурный стиль взаимодействия компонентов распределенной системы в компьютерной сети. REST определяет стиль взаимодействия (обмена данными) между разными компонентами системы, каждая из которых может физически располагаться в разных местах.
Данный архитектурный стиль представляет собой согласованный набор ограничений, учитываемых при проектировании распределенной системы. Эти ограничения иногда называют принципами REST:
\begin{enumerate}
	\item Приведение архитектуры к модели клиент-сервер. В основе данного ограничения лежит разграничение потребностей. Необходимо отделять потребности клиентского интерфейса от потребностей сервера, хранящего данные. Данное ограничение повышает переносимость клиентского кода на другие платформы, а упрощение серверной части улучшает масштабируемость системы. Само разграничение на “клиент” и “сервер” позволяет им развиваться независимо друг от друга; 
	\item Отсутствие состояния. Архитектура REST требует соблюдения следующего условия. В период между запросами серверу не нужно хранить информацию о состоянии клиента. Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса и идентификации клиента. Таким образом и сервер, и клиент могут "понимать" любое принятое сообщение, не опираясь при этом на предыдущие сообщения; 
	\item Кэширование. Клиенты могут выполнять кэширование ответов сервера. У тех, в свою очередь, должно быть явное или неявное обозначение как кэшируемых или некэшируемых, чтобы клиенты в ответ на последующие запросы не получали устаревшие или неверные данные. Правильное использование кэширования помогает полностью или частично устранить некоторые клиент-серверные взаимодействия, ещё больше повышая производительность и расширяемость системы;
	\item Единообразие интерфейса. К фундаментальным требованиям REST архитектуры относится и унифицированный, единообразный интерфейс. Клиент должен всегда понимать, в каком формате и на какие адреса ему нужно слать запрос, а сервер, в свою очередь, также должен понимать, в каком формате ему следует отвечать на запросы клиента. Этот единый формат клиент-серверного взаимодействия, который описывает, что, куда, в каком виде и как отсылать и является унифицированным интерфейсом. Каждый ресурс в REST должен быть идентифицирован посредством стабильного идентификатора, который не меняется при изменении состояния ресурса. Идентификатором в REST является URI;
	\item Слои. Под слоями подразумевается иерархическая структура сетей. Иногда клиент может общаться напрямую с сервером, а иногда — просто с промежуточным узлом. Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования; 
	\item Код по требованию (необязательное ограничение). Данное ограничение подразумевает, что клиент может расширять свою функциональность, за счет загрузки кода с сервера в виде апплетов или сценариев. 
\end{enumerate}

В общем случае REST является очень простым интерфейсом управления информацией без использования каких-то дополнительных внутренних прослоек. Каждая единица информации однозначно определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет строго заданный формат. Как происходит управление информацией сервиса – это целиком и полностью основывается на протоколе передачи данных. Для HTTP действие над данными задается с помощью методов: GET (получить), PUT (добавить, заменить), POST (добавить, изменить, удалить), DELETE (удалить).

\subsection{Формат передачи данных JSON}
JSON (JavaScript Object Notation) – это текстовый формат представления данных в нотации объекта JavaScript. Предназначен JSON, также как и некоторые другие форматы такие как XML и YAML, для обмена данными. Несмотря на происхождение от JavaScript, формат считается независимым от языка и может использоваться практически с любым языком программирования. JSON основан на двух структурах данных:
\begin{enumerate}
	\item Коллекция пар ключ/значение;
	\item Упорядоченный список значений.
\end{enumerate}

Это универсальные структуры данных. Почти все современные языки программирования поддерживают их в какой-либо форме. Объект JSON представляет собой заключённый в фигурные скобки список из пар ключ/значение. В коллекции ключ отделяется от значения с помощью знака двоеточия (:), а одна пара от другой - с помощью запятой (,). При этом ключ в JSON обязательно должен быть заключен в двойные кавычки. Значение ключа в JSON можно задать только в одном из следующих форматов: string (строкой), number (числом), object (объектом), array (массивом), boolean (логическим значением true или false) или null. Массив JSON представляет собой заключённый в квадратные скобки список из нуля или более значений, разделённых запятыми. Эти структуры могут быть вложенными.

\subsection{Стандарт JSON Web Token}
JSON Web Token (JWT) — это открытый стандарт (RFC 7519) представления данных для передачи между двумя или более сторонами в виде JSON-объекта. В клиент-серверных приложениях токены создаются сервером, подписываются секретным ключом и передаются клиенту, который в дальнейшем использует данный токен для подтверждения своей личности. Как правило, структурно JWT состоит из трех частей: 
\begin{enumerate}
	\item header — заголовок;
	\item payload — полезная нагрузка;
	\item signature — подпись.
\end{enumerate}
Заголовок и полезная нагрузка — обычные JSON-объекты, которые необходимо дополнительно закодировать при помощи алгоритма base64url. Закодированные части соединяются друг с другом, и на их основе вычисляется подпись, которая также становится частью токена. 
Заголовок — служебная часть токена. Он помогает приложению определить, каким образом следует обрабатывать полученный токен:

\{

	"typ": "JWT",
	
	"alg": "HS256"
	
\}


Поле typ определяет тип токена. Поле alg определяет алгоритм, использованный для генерации подписи. В приведенном случае был применен алгоритм HS256, в котором для генерации и проверки подписи используется единый секретный ключ. В полезной нагрузке передается любая информация, которая помогает приложению тем или иным образом идентифицировать пользователя и время жизни токена. Заголовок и полезная нагрузка кодируются при помощи алгоритма base64url, после чего объединяются в единую строку с использованием точки (".") в качестве разделителя. Генерируется подпись, которая добавляется к исходной строке так же через точку:
\begin{center}
header.payload.signature
\end{center}

Получив JWT от пользователя, приложение самостоятельно вычислит значение подписи и сравнит его с тем значением, которое было передано в токене. Если эти значения не совпадут, значит, токен был модифицирован или сгенерирован недоверенной стороной, и принимать такой токен и доверять ему приложение не будет. 

\subsection{Шаблон проектирования MVVM}

Паттерн MVVM  позволяет отделить логику приложения от визуальной части (представления). Данный паттерн является архитектурным, то есть он задает общую архитектуру приложения. MVVM паттерн был представлен Джоном Госсманом в 2005 году как модификация шаблона Presentation Model и был первоначально нацелен на разработку приложений в WPF\cite{2}. Cейчас данный паттерн вышел за пределы WPF и применяется в самых различных технологиях, в том числе при разработке под Android. MVVM состоит из трех компонентов:
\begin{enumerate}
	\item модели (Model);
	\item модели представления (ViewModel);
	\item представления (View)
\end{enumerate}
 На рисунке \ref{MVVMwpf} представлен взаимодействие этих компонентов.
\addimghere{MVVMwpf}{0.8}{Взаимодействие компонентов архитектуры MVVM}{MVVMwpf}

Модель описывает используемые в приложении данные. Модели могут содержать логику, непосредственно связанную с этими данными, например, логику валидации свойств модели. В то же время модель не должна содержать никакой логики, связанной с отображением данных и взаимодействием с визуальными элементами управления. 

View или представление определяет визуальный интерфейс, через который пользователь взаимодействует с приложением. 

ViewModel связывает модель и представление через механизм привязки данных. ViewModel также содержит логику по получению данных из модели, которые потом передаются в представление. И также VewModel определяет логику по обновлению данных в модели.

\subsection{Операционная система android}
Android - операционная система для мобильных телефонов, смартфонов планшетов и других устройств, которая основывается на ядре Linux. Изначально ОС Android разрабатывала компания Android Inc., но затем ее купила компания Google. На рисунке \ref{Android-Architecture} представлена архитектура операционной системы android.
\addimghere{Android-Architecture}{0.80}{Архитектура ОС Андроид}{Android-Architecture}

Уровень приложений (Applications).
В состав Android входит комплект базовых приложений: клиенты электронной почты и SMS, календарь, различные карты, браузер, программа для управления контактами и много другое. 

Уровень каркаса приложений (Application Framework). Android позволяет использовать всю мощь API, используемого в приложениях ядра. Архитектура построена таким образом, что любое приложение может использовать уже реализованные возможности другого приложения при условии, что последнее откроет доступ на использование своей функциональности. Таким образом, архитектура реализует принцип многократного использования компонентов ОС и приложений. Основой всех приложений является набор систем и служб:
\begin{enumerate}
	\item Система представлений (View System) – это богатый набор представлений с расширяемой функциональностью, который служит для построения внешнего вида приложений, включающий такие компоненты, как списки, таблицы, поля ввода, кнопки и т.п.
	\item Контент-провайдеры (Content Providers) – это службы, которые позволяют приложениям получать доступ к данным других приложений, а также предоставлять доступ к своим данным.
	\item Менеджер ресурсов (Resource Manager) предназначен для доступа к строковым, графическим и другим типам ресурсов.
	\item Менеджер извещений (Notification Manager) позволяет любому приложению отображать пользовательские уведомления в строке статуса.
	\item Менеджер действий (Activity Manager) управляет жизненным циклом приложений и предоставляет систему навигации по истории работы с действиями.
\end{enumerate}

Уровень библиотек (Libraries). Платформа Android включает набор C/C++ библиотек, используемых различными компонентами ОС. Для разработчиков доступ к функциям этих библиотек реализован через использование Application Framework.

Уровень среды исполнения (Android Runtime). В состав Android входит набор библиотек ядра, которые предоставляют большую часть функциональности библиотек ядра языка Java. В Android используется собственная реализация JVM под названием Android Runtime (ART), специально оптимизированная для работы на мобильных устройствах. В старых версиях Android (до 5.0 Lollipop) вместо ART использовалась другая реализация под названием Dalvik.

Уровень ядра Linux (Linux Kernel). Android основан на ОС Linux, тем самым платформе доступны системные службы ядра, такие как управление памятью и процессами, обеспечение безопасности, работа с сетью и драйверами. Также ядро служит слоем абстракции между аппаратным и программным обеспечением.

\subsection{Выбор и обоснование инструментов разработки}

Исходя из системных требований предъявляемых к реализуемому серверу, к выбору инструментов разработки накладываются следующие ограничения:
\begin{enumerate}
	\item Поддержка формата передачи данных JSON;
	\item Наличие библиотек для работы со стандартом JWT;
	\item Возможность реализации архитектурного стиля REST.
\end{enumerate}

В качестве базы данных было решено использовать NoSQL СУБД MongoDB\cite{3}. Подробное изучение данной СУБД позволило выявить ряд нижеописанных преимуществ для нашей системы:
\begin{enumerate}
	\item Документоориентированность – СУБД предназначена для хранения иерархических структур данных (документов).
	\item Представление в формате JSON – формат данных JSON удобен в интерпретации и использовании. В виду того, что серверная составляющая должна предоставлять RestAPI, MongoDB отлично подходит для реализации нашего сервиса.
	\item Гибкость и динамичность данных – MongoDB способен хранить
	как структурированные, так и не структурированные данные.
	\item Документация и ПО – данная СУБД является ПО с открытым исходным кодом, с отличной документацией и реализацией драйверов для подавляющего большинства языков программирования.
\end{enumerate}

Исходя из системных требований к проектируемому сервису, представление данных в формате JSON стал решающим фактором в выборе данного СУБД. Это позволит исключить использование дополнительных прослоек в виде ORM для преобразования данных.

Для реализации сервера используется язык программирования Python версии 3.8.5 и фреймворк для создания веб-приложений
Flask\cite{4}. Flask предоставляет гибкую настройку веб-приложения с минимальным количеством зависимостей. Пакетный менеджер pip предоставляет множество расширений для языка Python, благодаря чему реализация взаимодействия между компонентами системы сводится к написанию бизнес логики. Процесс написания программного кода и его отладки осуществлялся в интегрированной среде разработки PyCharm версии 2020.3.3. Для взаимодействия с базой данных используется рекомендованный способ для работы с MongoDB из среды Python пакет PyMongo\cite{5}. Пример подключения к базе данных:
\begin{lstlisting}
app.config["MONGO_URI"] = "mongodb://localhost:27017/barcode"
mongo = PyMongo(app)
\end{lstlisting}

Создается экземпляр класса клиента базы данных, который используется для обращения к данным. Благодаря тому, что данная база является документоориентированной с представлением объектов в типе BSON отсутствует миграция базы данных.

Для реализации стандарта аутентификации используется расширение
Flask-JWT-Extended\cite{6}, которое реализует весь необходимый функционал. Для встраивания данного функционала в программный код, достаточно добавить к методам ресурсов соответствующие декораторы доступа. При возникновении ошибки декоратор прерывает выполнение обработки запроса и возвращает соответствующее сообщение. По умолчанию access-токен валиден в течение 15 минут, а refresh-токен в течение 30 дней. Для авторизованного запроса необходимо передать параметр Authorization в заголовке запроса с содержимым: Bearer <соответствующий токен доступа (access/refresh)>.




\clearpage